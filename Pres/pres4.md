---
marp: true
math: mathjax
theme: foobar
class:
    - lead
header: Bash
paginate: true
# size: 4:3

---
# 

![logotyp](img/logo.png)

---

##   Что это? 

Bash (сокращение от «Bourne-again SHell») -- это стандартный интерпретатор команд на большинстве линукс систем. В его обязанности входит обработка и исполнение команд с помощью которых пользователь управляет компьютером.

---
### Преимущества

- Экономия сил и времени
- Одинаковый результат работы скриптов на разных системах
- Один и  тот же набор синтаксиса, что и в командной строке 
- Низкая сложность написания скриптов
___
### Недостатки

- Низкая скорость работы 
- Ограниченность в функциональности 
___

# Основы

Перед тем, как начать изучение, повторим некоторые стандартные команды, которые нам могут сегодня понадобиться:

- cd - перейти в директорию
- pwd - отображает текущую рабочую папку
- ls - посмотреть директорию
- mkdir - создать директорию
- cat - вывести содержимое фаила на экран
- touch - создать фаил
- mv - переместить или переименовать фаил

---

- rm - удалить фаил, папку
- cp - копировать файл, папку
- сv -переместить файл, папку (также переименовка)
- echo - вывести на экран строку
- | - перенаправление работы в следующую команду вместе с выводом или результатом
- \> - перенаправить поток (перезаписывает фаил)
- \>> - перенаправление потока в конец фаила

---

## Стандартный вывод
Большинство программ, работающих в интерфейсе командной строки, отображают результаты, направляя их на специальное приспособление, называемое стандартным выводом. Все, что отправляется в стандартный вывод, обычно отображается на экране. Но вывод можно перенаправить. 

---
Для его перенаправления в определенный файл, существует специальное обозначение «>» (знак больше), после которого указывается имя файла. В таком случае вывод результатов работы команды записывается в файл и на экран не выводится. Если файла с указанным именем не существует, то он будет создан. В противном случае, старое содержание файла будет стерто. Для записи в конец существующего файла вместо «>» следует использовать «>>» (два знака больше). Если файл отсутствует, то он будет создан, в противном случае вывод будет дописан в конец существующего файла. К тому же, перенаправлять можно и в другой поток, например, в поток ошибок.


---
## Стандартный ввод
Большинство программ, работающих в интерфейсе командной строки, ожидают ввод данных от пользователя с так называемого приспособления стандартный ввод.  Обычно, все, что набирается на клавиатуре, доступно для считывания программе из стандартного ввода. Но его можно перенаправить.  Чтобы перенаправить ввод из файла, существует специальное обозначение «<» (знак меньше) после которого следует указать имя файла. При перенаправлении ввода, вместо того, чтобы считывать символы с клавиатуры (стандартного устройства ввода), программа считывает их их указанного источника (файла).

---
## Каждый файл имеет три параметра доступа:
*Чтение* - разрешает получать содержимое файла, но на запись нет. Для каталога позволяет получить список файлов и каталогов, расположенных в нем;

*Запись* - разрешает записывать новые данные в файл или изменять существующие, а также позволяет создавать и изменять файлы и каталоги;

*Выполнение* - вы не можете выполнить программу, если у нее нет флага выполнения. Этот атрибут устанавливается для всех программ и скриптов, именно с помощью него система может понять, что этот файл нужно запускать как программу.

---

Каждый файл имеет три категории пользователей, для которых можно устанавливать различные сочетания прав доступа:
*Владелец* -  Обычно владелец имеет все права, чтение, запись и выполнение.
*Группа* - любая группа пользователей, существующая в системе. 
*Остальные* - все пользователи, кроме владельца и групп.

---
Рассмотрим права так, как они отображаются в системе:
--- - нет прав, совсем;
--x - разрешено только выполнение файла, как программы но не изменение и не чтение;
-w- - разрешена только запись и изменение файла;
-wx - разрешено изменение и выполнение, но в случае с каталогом, вы не можете посмотреть его содержимое;
r-- - права только на чтение;
r-x - только чтение и выполнение, без права на запись;
rw- - права на чтение и запись, но без выполнения;
rwx - все права;

---

## Как изменить права на фаил 
Чтобы изменить права на файл нужно использовать утилиту **chmod**. Она позволяет менять все флаги, включая специальные. 
Рассмотрим ее синтаксис:

chmod *опции категория действие флаг файл*

u - владелец файла;
g - группа файла;
o - другие пользователи

---
Например, всем пользователям полный доступ к файлу test5:
```bash
chmod +rwx test5
```

Или заберем все права у группы и остальных пользователей:
 ```bash
 chmod go-rwx test5
 ```

Дадим группе право на чтение и выполнение:
 ```bash
 chmod g+rx test5
 ```
---

# Что такое скрипт и с чем его едят

Скрипт - это простой список команд системы, записанный в файл с расширением **.sh**. Создание скриптов  сохранит  время и силы, которые тратятся на ввод последовательности команд всякий раз, когда необходимо их выполнить.

---
Любой bash-скрипт должен начинаться со строки:

```bash
#!/bin/bash 
```
Или более универсальная версия:
```bash
#!/usr/bin/env bash 
```
в этой строке после   **#!**   указывается путь к bash-интерпретатору, поэтому если он у вас установлен в другом месте(где, вы можете узнать набрав whereis bash) поменяйте её на ваш путь.

* *Во всех остальных случаях (кроме первой строки), после # указываются 
комментарии.*

---
## Поговорим о переменных

Пример работы с переменными:
```bash
# Пробелы до и после оператора "=" -- недопустимы!
var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo
```

Символ $, предшествующий имени переменной, указывает на то, что будет получено значение переменной.

---

В отличие от большинства других языков программирования, Bash не производит разделения переменных по "типам". По сути, переменные Bash являются строковыми переменными, но, в зависимости от контекста, Bash допускает целочисленную арифметику с переменными. Определяющим фактором здесь служит содержимое переменных.

---
## Область действия переменных

Глобальные переменные - это переменные, к которым можно получить доступ из любого места в скрипте независимо от области видимости. В Bash все переменные по умолчанию определены как глобальные, даже если они объявлены внутри функции.

Локальные переменные могут быть объявлены в теле функции с local ключевым словом и могут использоваться только внутри этой функции. Вы можете иметь локальные переменные с одинаковыми именами в разных функциях.

---
## Передача аргументов в Bash-скрипты

Чтобы передать любое количество аргументов в скрипт, просто поместите их сразу после имени скрипта, разделив их пробелом. 

Передаваемые параметры $1 , $2 , $3 ... $n , соответствующее положению параметра после имени скрипта.

\$# - Переменная содержит число позиционных параметров / аргументов.
\$*  И $@  - переменные содержат все позиционные параметры / аргументы.
\$0  - Переменная зарезервирована для имени скрипта.

---
## Первый скрипт

Создадим bash-скрипт **Hello_World.sh**, который выводил бы в терминал следующий результат:
```bash
$ ./Hello_World.sh
Hello, <Имя пользователя>!
```
* чтобы запустить скрипт нужно разрешить фаилу запускаться  
* это можно сделать, прописав в консоли: ```$ sudo chmod +x scriptname.sh```
---

Теперь додавим в скрипт переменные:

```bash
#!/bin/bash
parametr1=$1 
#присваиваем переменной parametr1 значение первого параметра скрипта
script_name=$0
#присваиваем переменной script_name значение имени скрипта
echo "Hello, $USER!"
echo "Вы запустили скрипт с именем $script_name и параметром $parametr1" 
#обращение к переменным осуществляется через $имя_переменной.
echo 'Вы запустили скрипт с именем $script_name и параметром $parametr1'
# здесь мы видим другие кавычки, разница в том, что в одинарных кавычках 
#не происходит подстановки переменных.
exit 0 
```
---

Кроме того, можно в переменную можно записать вывод какой-либо программы.
Пример:
```bash
path=$(ls -t)
```

---
Вложенные блоки и перенаправление ввода-вывода

```bash
#!/bin/bash
# Чтение строк из файла /etc/fstab.

File=/etc/fstab.txt

{
read line1 # считывает одну строку данных
read line2 # в добавок и следующую
} < $File

echo "Первая строка в $File :"
echo "$line1"
echo
echo "Вторая строка в $File :"
echo "$line2"

exit 0
```

---
# Математика и переменные

Арифметические операторы:

- \+ - сложение

- \- - вычитание

- \* - умножение

- / - деление

- \** - возведение в степень

- % - модуль (деление по модулю), возвращает остаток от деления

* А также битовые операции

---
Способы использования математических выражений:

```bash
let <выражение>
# или
((<пробел><выражение><пробел>)) 
# используется для написания скриптов в стиле С. Возвращает результат выражения
#И в первом и во втором случае можно присваивать в выражениях значения переменным
```

---
### Пример
```bash
let a="5 + 3"
(( b=5+3 ))
[[ $a -eq $b ]]
echo $?
```

---
## Условные операторы в Bash

Структура **if-then-else** используется следующим образом:

*if <команда или набор команд возвращающих код возврата(0 или 1)>
then <если выражение после if истино, то выполняется этот блок>
[elif <условное выражение>
then <если выражение после if истино, то выполняется этот блок>]
[else <если выражение после if ложно, тот этот>]
fi*

* В качестве условного выражения можно использовать любую программу
* 0 - true, все ненулевые числа - false
* [[ ]] - зарезервированное слово для проверки условий, является расширенной версией [ ]
---
### Пример
```bash
#!/bin/bash
source=$1 #в переменную source забрасываем первый параметр скрипта
dest=$2 #в переменную dest забрасываем второй параметр скрипта
if [[ "$source" -eq "$dest" ]] # в кавычках указываем имена переменных
#для сравнения. -eq - логическое сравнение обо    значающие "равны"
then # если они действительно равны, то
echo "значения $dest и $source равны!"
elif [[ $(( $source-$dest )) -ne 8 ]] # иначе если
then echo "Разность $source и $dest неравна 8-ми!"
else # если же они не равны
echo "Разность $source и $dest равна 8-ми!"
fi #обозначаем окончание условия.

exit 0
```

---

# Циклы

Цикл - это блок команд, который исполняется многократно до тех пор, пока не будет выполнено условие выхода из цикла.
```bash
for arg in [list]
do
 команда(ы)...
done
```
* На каждом проходе цикла, переменная-аргумент цикла arg последовательно, одно за другим, принимает значения из списка list

---
### Пример

```bash
#!/bin/bash
# Список планет.

for planet in Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун Плутон
do
  echo $planet
done

# Если 'список аргументов' заключить в кавычки, то он будет 
#восприниматься как единственный аргумент .
for planet in "Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун Плутон"
do
  echo $planet
done

echo 

exit 0
```

---
### Результат
```bash
Меркурий
Венера
Земля
Марс
Юпитер
Сатурн
Уран
Нептун
Плутон

Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун Плутон
```

---
### Еще пример

Применим С-ный стиль:
```bash
#!/bin/bash
for (( index=1; index<=8; index++))
do
  echo "Итерация - $index"
done

exit 0
```

---
## while

Оператор while проверяет условие перед началом каждой итерации и если условие истинно (если код возврата равен 0), то управление передается в тело цикла. В отличие от циклов for, циклы while используются в тех случаях, когда количество итераций заранее не известно.
```bash
while <условное выражение>
do
 <команды>
done
```

---
### Пример 
```bash
#!/bin/bash

var0=0
LIMIT=$1

while [ "$var0" -le "$LIMIT" ] # <=
do
  echo -n "$var0 " # -n подавляет перевод строки.
  ((var0+=1))
done

echo
# Вывод чисел от 0 до параметра
exit 0
```
___

## case

Не является циклом, поскольку не предусматривают многократное исполнение блока кода. Но они, как и циклы, управляют ходом исполнения программы, в зависимости от начальных или конечных условий.

Конструкция case эквивалентна конструкции switch в языке C/C++. Она  выполняет соответсвующий участок кода, в зависимости от результатов проверки условий. 

---

*case (in) / esac*:
```bash
case "$variable" in

 "$condition1" )
 command...
 ;;

 "$condition2" )
 command...
 ;;

esac
```
---
•	Заключать переменные в кавычки необязательно, поскольку здесь не производится разбиения на отдельные слова.
•	Каждая строка с условием должна завершаться правой (закрывающей) круглой скобкой.
•	Каждый блок команд, отрабатывающих по заданному условию, должен завершаться двумя символами точка-с-запятой **;;** .
•	Блок case должен завершаться ключевым словом esac (case записанное в обратном порядке).

---
# Функции

Функция Bash - это, по сути, набор команд, которые можно вызывать множество раз. Цель функции - помочь вам сделать ваши bash-скрипты более читабельными и избежать повторного написания одного и того же кода. 
Синтаксис объявления функции bash прост. Функции могут быть объявлены в двух разных форматах.

---

Первый формат начинается с имени функции, за которым следуют скобки. Это предпочтительный и более используемый формат.

```bash
function_name () {
  commands
} 
```
Второй формат начинается с зарезервированного слова function , за которым следует имя функции.

```bash
function function_name {
  commands
} 
```

---
* Команды между фигурными скобками ( {} ) называются телом функции. Фигурные скобки должны быть отделены от тела пробелами или переводами строки.
* Определение функции не выполняет ее. Чтобы вызвать функцию bash, просто используйте имя функции. Команды между фигурными скобками выполняются всякий раз, когда функция вызывается в сценарии оболочки.
* Определение функции должно быть помещено перед любыми вызовами функции.

---
```bash
#!/bin/bash

hello_world () {
   echo 'hello, world'
}

hello_world 
```
---
```bash
#!/bin/bash

var1='A'
var2='B'

my_function () {
  local var1='C'
  var2='D'
  echo "Inside function: var1: $var1, var2: $var2"
}

echo "Before executing function: var1: $var1, var2: $var2"

my_function

echo "After executing function: var1: $var1, var2: $var2"
```

---
```bash
Before executing function: var1: A, var2: B
Inside function: var1: C, var2: D
After executing function: var1: A, var2: D
```

---
Bash не позволяют вам возвращать значение при вызове. Когда функция bash завершает свою работу, ее возвращаемое значение является состоянием последнего оператора, выполненного в функции, 0 для успеха и ненулевого десятичного числа в диапазоне 1 - 255 для отказа.

Статус возврата можно указать с помощью return ключевого слова, и оно присваивается переменной  "$?" 

---
```bash#!/bin/bash

my_function () {
  echo "some result"
  return 55
}

my_function
echo $?
```
```bash
some result
55
```
---

## Пару слов о IFS

Эта переменная задает разделители полей (Internal Field Separator), которые используются при операции разделения слов при преобразованиях командной строки, выполняемых оболочкой перед тем, как запустить командную строку на исполнение.

Изменение переменной IFS:
```bash
olsIFS=$IFS
IFS=$'\n'
# после работы возращем стандартное значение
IFS=$oldIFS
```

---


![down](img/aatt.jpeg)

---
## Полезные команды и программы

Программы:
- man -- документация для программ
- stat -- выводит форматируемый полный список информации по фаилу
- tar -- архиватор

Команды:
- read -- чтение из потока ввода
- и другие 😁

---

# Общее задание

---
# Индивидуальное задание
---
# Полезные ссылки
https://www.opennet.ru/docs/RUS/bash_scripting_guide/

https://vk.com/@linuxclub

# Спасибо за внимание!👋